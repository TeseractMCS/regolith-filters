import JSON5 from "json5";
import path from "path";
import { build } from "esbuild";
import { readFileSync, writeFileSync, mkdirSync } from "fs";
import { ParseModule } from "./util/ParseModule.js";
import { randomUUID } from "crypto";
import { Manifest } from "./util/interface/Manifest.js";
import { PluginData } from "./util/interface/PluginData.js";

const settings = process.argv[2] ? JSON.parse(process.argv[2]) : {};
// Change the current working directory to the root directory where config.json exists; this file is supposed to always exist, as the filter is running inside .regolith/tmp folder
process.chdir(process.env.ROOT_DIR);
// Get the regolith config file and parse it to JSON
const regolithConfig = JSON5.parse(readFileSync("config.json").toString());
/**
 * .regolith data path
 */
const regolithPath = "./.regolith";
/**
 * .regolith temp path
 */
const regolithTmp = "./.regolith/tmp";
/**
 * Path to the script source files
 */
const srcPath = regolithConfig.regolith.dataPath;
/**
 * Path to behavior and assets files, also where teseract.plugin.json file is located
 */
const resourcesPath = path.join(srcPath, "../resources");
// Get the teseract.plugin.json file and parse it to JSON using JSON5
const teseractPlugin: PluginData = JSON5.parse(
    readFileSync(path.join(resourcesPath, "teseract.script.json")).toString(),
);
const BPManifest: Manifest = JSON5.parse(
    readFileSync(
        path.join(resourcesPath, "/behavior/manifest.json"),
    ).toString(),
);
for (const dependency of teseractPlugin.modules) {
    const { name, version } = ParseModule(dependency);
    if (BPManifest.dependencies.find((dep) => dep.module_name == name)) {
        console.warn(
            `Module ${name}@${version} is already present in the manifest, and won't be overriden`,
        );
    } else {
        BPManifest.dependencies.unshift({
            module_name: name,
            version: version,
        });
    }
}
const RPManifest: Manifest = JSON5.parse(
    readFileSync(path.join(resourcesPath, "/assets/manifest.json")).toString(),
);
BPManifest.dependencies.unshift({
    uuid: RPManifest.header.uuid,
    version: RPManifest.header.version,
});
const scriptModule = BPManifest.modules.find(
    (module) => module.type == "script",
);
if (scriptModule) {
    console.warn(
        `Scripting module is already present in the manifest, and won't be overriden. WARNING: This may cause entrypoint file to differ from entry point auto-generated by the vanilla loom.`,
    );
} else {
    BPManifest.modules.push({
        type: "script",
        language: "javascript",
        entry: "scripts/index.js",
        uuid: randomUUID(),
        version: teseractPlugin.version,
    });
}

writeFileSync(
    path.join(regolithTmp, "/RP/manifest.json"),
    JSON.stringify(RPManifest, null, 5),
);
writeFileSync(
    path.join(regolithTmp, "/BP/manifest.json"),
    JSON.stringify(BPManifest, null, 5),
);
class Tesselator {
    private static index: string;
    static writeIndex() {
        mkdirSync(regolithTmp + "/BP/scripts");
        writeFileSync(regolithTmp + "/data/index.ts", this.index);
    }
    static build() {
        process.chdir(regolithTmp);

        build({
            entryPoints: ["data/index.ts"],
            bundle: true,
            minify: settings.minify ?? false,
            outfile: "BP/scripts/index.js",
            platform: "node",
            target: "es2020",
            external: [
                "@minecraft/server",
                "@minecraft/server-ui",
                ...teseractPlugin.external,
            ],
            allowOverwrite: true,
            format: "esm",
            logLevel: "info",
            tsconfig: "../../tsconfig.json",
            plugins: [],
            treeShaking: false,
        }).catch((error) => {
            throw error;
        });
    }
    static readPluginData() {
        const { entryPoints } = teseractPlugin;
        if (entryPoints.length == 0) {
            throw new Error("No entry points specified!");
        }
        const indexImports = [];
        for (const entry of entryPoints) {
            indexImports.push(`import  "${entry}";`);
        }
        this.index = indexImports.join("\n");
    }
    static start() {
        this.readPluginData();
        this.writeIndex();
        this.build();
    }
}
Tesselator.start();
